#! /usr/bin/env python
import numpy as np
import re
import ap.mesh.meshtools

def parser_factory(*args):
    """
    Instantiate the right parser based on input. See MeshParser for
    arguments.
    """
    if re.search(r"\.mesh\s*$", args[0]):
        parser = ParseMESHFormat(args[0])
    elif re.search(r"\.msh\s*$", args[0]):
        raise NotImplementedError(".msh format not yet supported")
    elif re.search(r"\.txt\s*$", args[0]) and re.search(r"\.txt$", args[1]):
        parser = ParseTXTFormat(*args)
    else:
        raise ValueError("Mesh format not supported")

    return parser

class MeshParser(object):
    # the rest of this docstring will be filled in by particular classes.
    """
    Properties
    ----------
    * elements : A numpy array listing the node numbers of every element;
      for example,

        print(t.elements)

        => [[ 1  9  4 10 11  8]
            [ 1  2  9  5 12 10]
            [ 2  3  9  6 13 12]
            [ 3  4  9  7 11 13]]

      for a quadratic mesh with four elements.

    * nodes : a array of every node's coordinates, where row number
      corresponds to node number - 1.

    * edges :

        print(t.edge_collections)
        => {'boundary': set([(3, 4, 7, 3), (4, 1, 8, 4), (2, 3, 6, 2),
            (1, 2, 5, 1)])}

    Methods
    -------
    * savetxt() : Save the mesh data (edge collections, nodes, elements).
    """
    def __init__(self):
        raise NotImplementedError("This function must be defined by an "
                                  + "inheriting class.")

    def savetxt(self):
        """
        Save the output files of the parsed mesh. Assumes C0 elements.

            nodes.txt    : all nodal coordinates
            elements.txt : the element array for Argyris

        and for each edge collection with name NAME:

            NAME_edges.txt : list of edges corresponding to name NAME.
        """
        np.savetxt("nodes.txt", self.nodes)
        np.savetxt("elements.txt", self.elements, fmt="%d")

        for name, collection in self.edge_collections.items():
            np.savetxt(name + '_nodes.txt', np.fromiter(collection, int),
                       fmt='%d')

    def _parse_section(self, pattern, line_parse_function):
        raise NotImplementedError("This function must be defined by an "
                                  + "inheriting class.")

class ParseMESHFormat(MeshParser):
    """
    Parse a .mesh file generated by GMSH.

    Required Arguments
    ------------------
    * mesh_file : file path to the .mesh file.
    """
    __doc__ += MeshParser.__doc__
    def __init__(self, mesh_file):
        self._mesh_file = mesh_file

        elements = self._parse_section("Triangles",
                                       lambda x : tuple(map(int,x.split()[0:-1])))
        self.elements = np.vstack(elements)

        nodes = self._parse_section("Vertices",
                            lambda x : (tuple(map(float, x.split()[0:-1])),
                                        int(x.split()[-1])))
        self.nodes = np.vstack(map(lambda x : x[0], nodes))

        # a .mesh value does not always have this section.
        try:
            self.edges = \
                self._parse_section("Edges", lambda x : tuple(map(int,x.split())))
        except ValueError:
            self.edges = list()

    def _parse_section(self, pattern, line_parse_function):
        """
        Parse one chunk of the file, starting with some regex. Apply the
        function 'line_parse_function' to each line in the section. Return a
        list of the results. Stop when we get to another section (triggered by
        reaching another line with alphabetical characters).
        """
        found_section = False
        found_count = False
        parsed_section = []
        with open(self._mesh_file) as f:
            for line in f:
                if (not found_section) and re.search(pattern,line):
                    found_section = True

                # if there is a lone number then we are on the next line. Ignore
                # it.
                if found_section and (not found_count) and re.search("^ *[0-9]+$",
                                                                     line):
                    found_count = True
                    continue

                # if we have found another string then the section is over.
                if found_section and found_count and re.search("^ *[A-Z]?[a-z]+",
                                                               line):
                    break

                if found_section and found_count and (len(line) > 1):
                    parsed_section.append(line_parse_function(line))

        if not found_section:
            raise ValueError("Section with pattern " + pattern + " not found")
        return parsed_section

# TODO make sure that it can parse comments correctly.
class ParseTXTFormat(MeshParser):
    """
    Parse a mesh stored in plain text files: classically nodes.txt and
    elements.txt.

    Required Arguments
    ------------------
    * elements_file : file path to the text file containing the element
      connectivity matrix.
    * nodes_file : file path to the text file containing the node
      coordinates.
    """
    __doc__ += MeshParser.__doc__
    def __init__(self, file1, file2, special_borders = None,
                 default_border = 'land'):
        if special_borders:
            raise NotImplementedError("Nonhomogeneous borders are not"
                                      + " supported for this format.")

        # figure out which file corresponds to elements and which corresponds to
        # nodes. The node array must have more rows than the element array.
        array1 = np.loadtxt(file1)
        array2 = np.loadtxt(file2)
        if array1.shape[0] > array2.shape[0]:
            nodes_file = file1
            elements_file = file2
        else:
            elements_file = file1
            nodes_file = file2

        self.elements = np.loadtxt(elements_file, dtype=int)
        self.nodes = np.loadtxt(nodes_file, dtype=float)

        self.edges = list()

class ParseMSHFormat(MeshParser):
    """
    Parse a mesh stored in the .msh format, the standard file format for GMSH.

    Required Arguments
    ------------------
    * mesh_file : file path to the .msh file.
    """
    __doc__ += MeshParser.__doc__
    def __init__(self, mesh_file):
        self._mesh_file = mesh_file

        mesh_format = self._parse_section("MeshFormat",
                                          lambda x : tuple(x.split()),
                                          has_count = False)
        if mesh_format[0][0] != "2.2":
            raise ValueError("Unsupported .msh version")

        elements = self._parse_section("Elements",
                                       lambda x : tuple(map(int,x.split()[1:-1])))
        # hard-coded list of triangular entities. See GMSH documentation for
        # more details.
        triangles = map(lambda x : tuple(x[5:]),
                        filter(lambda x : x[0] in [2,9,20,21,22,23,24,25], elements))
        edges = map(lambda x : tuple(x[3:]) + tuple([x[2]]),
                    filter(lambda x : x[0] in [1, 8], elements))
        try:
            self.elements = np.vstack(triangles)
        except ValueError as np_error:
            raise ValueError(np_error.value + ". Ensure that the mesh is"
                             " conforming (all elements the same order)")

        self.edges = edges
        nodes = self._parse_section("Nodes",
                            lambda x : (tuple(map(float, x.split()[0:-1])),
                                        int(x.split()[-1])))
        self.nodes = np.vstack(map(lambda x : x[0], nodes))

    def _parse_section(self, pattern, line_parse_function, has_count = True):
        """
        Parse one chunk of the file, starting with some regex. Apply the
        function 'line_parse_function' to each line in the section. Return a
        list of the results. Stop when we get to another section (triggered by
        reaching another line with alphabetical characters).
        """
        found_section = False
        found_count = False
        parsed_section = []
        if not has_count:
            found_count = True

        with open(self._mesh_file) as f:
            for line in f:
                if (not found_section) and re.search(pattern,line):
                    found_section = True
                    continue

                # if there is a lone number then we are on the next line. Ignore
                # it.
                if found_section and (not found_count) and re.search("^ *[0-9]+$",
                                                                     line):
                    found_count = True
                    continue

                # if we have found another string then the section is over.
                if found_section and found_count and re.search("^ *\$\w+", line):
                    break

                # correctly ignore blank lines.
                if found_section and found_count and not re.match("\s+$", line):
                    parsed_section.append(line_parse_function(line))

        if not found_section:
            raise ValueError("Section with pattern " + pattern + " not found")
        return parsed_section
