#! /usr/bin/env python
import re
import numpy as np
import Mesh

class ParseMESHFormat(object):
    """
    Parse a .mesh file generated by GMSH.

    Required Arguements
    -------------------
    * mesh_file : the file path to the .mesh file being parsed.
    * surface_number : the number of the Physical Surface used by GMSH to generate
      the mesh.

    Optional Arguements
    -------------------
    * projection : some function that takes a M x N numpy array of cartesian
      coordinates and returns some 2 x N numpy array of their projection on to
      the plane. Defaults to simply ignoring all but the first two coordinates
      per node.

    * special_borders : a dictionary correlating names with GMSH 'Physical
      Line' attributes. For example,

          special_borders = {'open' : (1,2)}

      will correlate edges on Physical Lines 1 and 2 with the 'land' edge
      collection.

    * other_border : the default edge collection for any edges that are not in a
      special_border collection. Defaults to 'land'.

    Properties
    ----------
    * element_array : A numpy array listing the node numbers of every element;
      for example,

        print t.element_array

        => [[ 1  9  4 10 11  8]
            [ 1  2  9  5 12 10]
            [ 2  3  9  6 13 12]
            [ 3  4  9  7 11 13]]

      for a quadratic mesh with four elements.

    * node_array : a array of every node's coordinates, where row number
      corresponds to node number + 1.

    * edge_collections : a dictionary relating the border names to the edge tuples
      in the .mesh format that fall along that border. For example,

        print t.edge_collections
        => {'boundary': set([(3, 4, 7, 3), (4, 1, 8, 4), (2, 3, 6, 2), (1, 2, 5, 1)])}

    Methods
    -------
    * save_argyris_outfiles : convert the mesh to be an Argyris mesh and save
      the results.
    * save_outfiles : Save the mesh data as-is (C0 elements).

    """
    def __init__(self, mesh_file, surface_number, projection = lambda t : t[:,0:2],
                 special_borders = {}, other_border = 'land'):

        self.projection = projection
        self.mesh_file = mesh_file
        self.special_borders = special_borders

        nodes = self._parse_section("Vertices",
                            lambda x : (map(float, x.split()[0:-1]), int(x.split()[-1])))

        self.node_array = self.projection(np.vstack(map(lambda x : x[0], nodes)))

        elements = self._parse_section("Triangles",
                                       lambda x : map(int,x.split()[0:-1]))
        self.element_array = np.vstack(elements)

        self.edges = self._parse_section("Edges",
                                         lambda x : tuple(map(int,x.split())))

        other_borders = set(self.edges)
        self.edge_collections = dict()
        for name, border in self.special_borders.iteritems():
            self.edge_collections[name] = set(filter(lambda x : x[-1] in border,
                                                       self.edges))
            other_borders.difference_update(self.edge_collections[name])

        if other_borders: # do not update if it is empty
            self.edge_collections[other_border] = other_borders

    def _parse_section(self, pattern, line_parse_function):
        """
        Parse one chunk of the file, starting with some regex. Apply the
        function 'line_parse_function' to each line in the section. Return a
        list of the results. Stop when we get to another section (triggered
        by reaching another line with alphabetical characters).
        """
        found_section = False
        found_count = False
        parsed_section = []
        with open(self.mesh_file) as f:
            for line in f:
                if (not found_section) and re.search(pattern,line):
                    found_section = True

                if found_section and (not found_count) and re.search("^ [0-9]+$",line):
                    # if there is a lone number then we are on the next line. Ignore it.
                    found_count = True
                    continue

                if found_section and found_count and re.search("[A-Za-z]",line):
                    # if we have found another string then the section is over.
                    break

                if found_section and found_count:
                    parsed_section.append(line_parse_function(line))
        return parsed_section

    def build_argyris(self):
        "Convert the mesh to an Argyris mesh."
        # check to make sure the input mesh is quadratics.
        if self.element_array.shape[1] != 6:
            raise ValueError("requires a quadratic mesh")

        node_collections = []
        # build the collections of boundary nodes. Simultaneously delete them
        # from the interior node containers.
        interior_normal_derivatives = set(self.element_array[:, 3:].flatten())
        interior_function_values = set(self.element_array[:, 0:3].flatten())

        for border_name, collection in self.edge_collections.iteritems():
            function_values = set([x[0] for x in collection] +
                                  [x[1] for x in collection])
            normal_derivatives = set([x[2] for x in collection])
            node_collections.append(
                Mesh.ArgyrisNodeCollection(function_values,
                                            normal_derivatives,
                                            name = border_name))
            interior_normal_derivatives.difference_update(normal_derivatives)
            interior_function_values.difference_update(function_values)

        node_collections.append(
            Mesh.ArgyrisNodeCollection(interior_function_values,
                                       interior_normal_derivatives,
                                       name = 'interior'))
        return Mesh.ArgyrisMesh(node_collections, self.element_array)

    def save_QGE_outfiles(self):
        """
        Convert the mesh to an Argyris mesh (requires that mesh_file be
        quadratic) and save the following files:

            nodes.txt    : all nodal coordinates
            elements.txt : the element array for Argyris
            unodes.txt   : nodes corresponding to function values

        and for each border in edge_collections with key NAME, as well as the
        interior nodes:

            NAMEdx.txt       : nodes approximating x-derivatives
            NAMEdy.txt       : nodes approximating y-derivatives
            NAMEnormal.txt   : nodes approximating normal derivatives
            NAMEfunction.txt : nodes approximating function values
            NAMEall.txt      : all nodes in the collection.
        """

        argyris = self.build_argyris()

        # construct the nodal coordinates array.
        all_nodes = np.zeros((argyris.elements.max(),2))
        all_nodes[0:self.node_array.shape[0], :] = self.node_array
        for collection in argyris.node_collections:
            for pair in collection.stacked_nodes.iteritems():
                for new_node in pair[1]:
                    all_nodes[new_node - 1, :] = self.node_array[pair[0] - 1, :]

        # save node indicies containing function values.
        u_nodes = np.unique(argyris.elements[:,0:3].flatten())

        # fix the numbering on the argyris.elements to match QGE code.
        normal_derivatives1 = argyris.elements[:,3].copy()
        normal_derivatives2 = argyris.elements[:,4].copy()
        normal_derivatives3 = argyris.elements[:,5].copy()

        first_nodes  = argyris.elements[:,6:11].copy()
        second_nodes = argyris.elements[:,11:16].copy()
        third_nodes  = argyris.elements[:,16:21].copy()

        argyris.elements[:,18]    = normal_derivatives1
        argyris.elements[:,19]    = normal_derivatives3
        argyris.elements[:,20]    = normal_derivatives2

        argyris.elements[:,3:5]   = first_nodes[:,0:2]
        argyris.elements[:,9:12]  = first_nodes[:,2:5]

        argyris.elements[:,5:7]   = second_nodes[:,0:2]
        argyris.elements[:,12:15] = second_nodes[:,2:5]

        argyris.elements[:,7:9]   = third_nodes[:,0:2]
        argyris.elements[:,15:18] = third_nodes[:,2:5]

        np.savetxt('nodes.txt', all_nodes)
        np.savetxt('elements.txt', argyris.elements, fmt="%d")
        np.savetxt('unodes.txt', u_nodes, fmt="%d")

        # save the information stored in the node collections as well.
        for collection in argyris.node_collections:
            collection.write_to_files()

    def save_outfiles(self):
        """
        Save the output files of the parsed mesh. Assumes C0 elements.

            nodes.txt    : all nodal coordinates
            elements.txt : the element array for Argyris
            interiornodes.txt : interior nodes

        and for each edge collection with name NAME:

            NAMEnodes.txt : a list of all nodes on the named edge.
        """

        np.savetxt('nodes.txt', self.node_array)
        np.savetxt('elements.txt', self.element_array, fmt="%d")

        node_collections = []
        interior_nodes = set(list(self.element_array.flatten()))
        for border_name, collection in self.edge_collections.iteritems():
            # hack to flatten tuples of integers
            function_values = set(np.array([x[0:-1] for x in collection]).flatten())
            print function_values
            interior_nodes.difference_update(function_values)
            np.savetxt(border_name + 'nodes.txt',
                       np.unique(np.array(list(function_values))), fmt="%d")

        np.savetxt('interiornodes.txt', np.sort(list(interior_nodes)), fmt="%d")
