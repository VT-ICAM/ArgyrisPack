#! /usr/bin/env python

import numpy as np
import re
import Mesh
import pdb

class ParseMESHFormat(object):
    """
    Parse a .mesh file generated by GMSH.

    Required Arguements
    -------------------
    * mesh_file : file path to the .mesh file.

    Optional Arguements
    -------------------
    * projection : some function that takes a M x N numpy array of cartesian
      coordinates and returns some 2 x N numpy array of their projection on to
      the plane. Defaults to simply ignoring all but the first two coordinates
      per node:

          projection = lambda t : t[:,0:2]

    * special_borders : a dictionary correlating names with GMSH 'Physical
      Line' attributes. For example,

          special_borders = {'open' : (1,2)}

      will correlate edges on Physical Lines 1 and 2 with the 'land' edge
      collection.

    * other_border : the default edge collection for any edges that are not in a
      special_border collection. Defaults to 'land'.

    Properties
    ----------
    * elements : A numpy array listing the node numbers of every element;
      for example,

        print t.elements

        => [[ 1  9  4 10 11  8]
            [ 1  2  9  5 12 10]
            [ 2  3  9  6 13 12]
            [ 3  4  9  7 11 13]]

      for a quadratic mesh with four elements.

    * nodes : a array of every node's coordinates, where row number
      corresponds to node number + 1.

    * edge_collections : a dictionary relating the border names to the edge tuples
      in the .mesh format that fall along that border. For example,

        print t.edge_collections
        => {'boundary': set([(3, 4, 7, 3), (4, 1, 8, 4), (2, 3, 6, 2), (1, 2, 5, 1)])}

    Methods
    -------
    * save_argyris_outfiles : convert the mesh to be an Argyris mesh and save
      the results.

    * save_outfiles : Save the mesh data as-is (C0 elements).

    * mesh_representation : return a Mesh object containing information from
      the parsed .mesh file.
    """
    def __init__(self, mesh_file, projection = lambda t : t[:,0:2],
                 special_borders = {}, other_border = 'land'):

        self.projection = projection
        self.mesh_file = mesh_file
        self.special_borders = special_borders

        nodes = self._parse_section("Vertices",
                            lambda x : (tuple(map(float, x.split()[0:-1])),
                                        int(x.split()[-1])))

        self.nodes = self.projection(np.vstack(map(lambda x : x[0], nodes)))

        elements = self._parse_section("Triangles",
                                       lambda x : tuple(map(int,x.split()[0:-1])))
        self.elements = np.vstack(elements)

        self.edges = self._parse_section("Edges",
                                         lambda x : tuple(map(int,x.split())))
        other_borders = set(self.edges)
        self.edge_collections = dict()

        for name, border in self.special_borders.items():
            self.edge_collections[name] = set(filter(lambda x : x[-1] in border,
                                                       self.edges))
            other_borders.difference_update(self.edge_collections[name])

        if other_borders: # do not update if it is empty
            self.edge_collections[other_border] = other_borders

    def mesh_representation(self):
        "Return the Mesh class representation of the object."
        node_collections = {}
        interior_nodes = set(range(1,self.elements.max() + 1))

        for name, edge_collection in self.edge_collections.items():
            new_collection = {x for sublist in edge_collection
                                for x in sublist[0:-1]}
            node_collections[name] = new_collection
            interior_nodes.difference_update(new_collection)

        if interior_nodes:
            node_collections['interior'] = interior_nodes

        return Mesh.Mesh(self.elements, self.nodes, node_collections)

    def argyris_representation(self):
        "Return an Argyris mesh built by adding 5 more nodes on to each corner."
        # check to make sure the input mesh is quadratics.
        if self.elements.shape[1] != 6:
            raise ValueError("requires a quadratic mesh")

        node_collections = []
        # build the collections of boundary nodes. Simultaneously delete them
        # from the interior node containers.
        interior_function_values = set(self.elements[:, 0:3].flatten())
        interior_normal_derivatives = set(self.elements[:, 3:6].flatten())

        for border_name, collection in self.edge_collections.items():
            # save left points of edges.
            function_values = {x[0] for x in collection}
            normal_derivatives = {x[2] for x in collection}
            edges = {tuple(x[0:3]) for x in collection}

            node_collections.append(Mesh.ArgyrisNodeCollection(function_values,
                interior_normal_derivatives, edges, name = border_name))
            interior_function_values.difference_update(function_values)
            interior_normal_derivatives.difference_update(normal_derivatives)

        node_collections.append(Mesh.ArgyrisNodeCollection(
            interior_function_values, interior_normal_derivatives, [],
            name = 'interior'))

        return Mesh.ArgyrisMesh(node_collections, self.elements,
                                self.nodes)

    def save_QGE_outfiles(self):
        """
        Convert the mesh to an Argyris mesh (requires that mesh_file be
        quadratic) and save the following files:

            nodes.txt    : all nodal coordinates
            elements.txt : the element array for Argyris
            unodes.txt   : nodes corresponding to function values

        and for each border in edge_collections with key NAME, as well as the
        interior nodes:

            NAME_dx.txt       : nodes approximating x-derivatives
            NAME_dy.txt       : nodes approximating y-derivatives
            NAME_normal.txt   : nodes approximating normal derivatives
            NAME_function.txt : nodes approximating function values
            NAME_all.txt      : all nodes in the collection.
        """
        self.argyris_representation().save_QGE_files()

    def save_outfiles(self):
        """
        Save the output files of the parsed mesh. Assumes C0 elements.

            nodes.txt    : all nodal coordinates
            elements.txt : the element array for Argyris

        and for each node collection with name NAME:

            NAME_nodes.txt : node numbers in a collection.
        """
        mesh = self.mesh_representation()

        np.savetxt('nodes.txt', self.nodes)
        np.savetxt('elements.txt', self.elements, fmt='%d')

        for name, collection in mesh.node_collections.items():
            np.savetxt(name + '_nodes.txt', np.fromiter(collection, np.int),
                       fmt='%d')

    def _parse_section(self, pattern, line_parse_function):
        """
        Parse one chunk of the file, starting with some regex. Apply the
        function 'line_parse_function' to each line in the section. Return a
        list of the results. Stop when we get to another section (triggered
        by reaching another line with alphabetical characters).
        """
        found_section = False
        found_count = False
        parsed_section = []
        with open(self.mesh_file) as f:
            for line in f:
                if (not found_section) and re.search(pattern,line):
                    found_section = True

                if found_section and (not found_count) and re.search("^ [0-9]+$",
                                                                     line):
                    # if there is a lone number then we are on the next
                    # line. Ignore it.
                    found_count = True
                    continue

                if found_section and found_count and re.search("^ *[A-Z]?[a-z]+",
                                                               line):
                    # if we have found another string then the section is over.
                    break

                if found_section and found_count:
                    parsed_section.append(line_parse_function(line))
        return parsed_section
